<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mediscribe – Live Medical Transcribe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f172a;
      --panel:#0b1226;
      --card:#101a33;
      --ink:#e5f0ff;
      --muted:#8aa4d6;
      --accent:#3b82f6;
      --accent-2:#22c55e;
      --warn:#f59e0b;
      --danger:#ef4444;
      --pill:#1e293b;
      --shadow:0 10px 30px rgba(0,0,0,.35), inset 0 -1px 0 rgba(255,255,255,.04);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:radial-gradient(1200px 600px at 20% -10%, #0c1540 0%, transparent 60%),
                 radial-gradient(900px 600px at 120% 20%, #042b53 0%, transparent 40%),
                 var(--bg);
      color:var(--ink); font:500 16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    }
    .wrap{max-width:1100px; margin:auto; padding:32px}
    header{display:flex; gap:16px; align-items:center; margin-bottom:24px}
    .logo{
      width:44px; height:44px; display:grid; place-items:center;
      border-radius:12px; background:linear-gradient(135deg,#0ea5e9, #22c55e);
      box-shadow:var(--shadow); font-weight:800; color:#001220;
    }
    h1{font-size:22px; margin:0;}
    .sub{color:var(--muted); margin-top:2px; font-size:14px}

    .grid{display:grid; grid-template-columns: 1.2fr .8fr; gap:18px}
    @media (max-width: 960px){ .grid{grid-template-columns:1fr} }

    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.04), transparent 60%),
                 var(--card);
      border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:18px 18px 16px; box-shadow:var(--shadow);
    }
    .toolbar{display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:14px}
    .btn{
      appearance:none; border:0; border-radius:12px; padding:12px 16px; cursor:pointer; color:#071226;
      font-weight:700; letter-spacing:.2px; transition:.15s transform ease, .15s background ease, .15s opacity ease;
      display:inline-flex; align-items:center; gap:10px; user-select:none;
    }
    .btn:disabled{opacity:.6; cursor:not-allowed}
    .primary{background:linear-gradient(135deg, #3b82f6, #22c55e)}
    .stop{background:linear-gradient(135deg, #ef4444, #f59e0b)}
    .ghost{background:#0b1226; color:var(--ink); border:1px solid rgba(255,255,255,.09)}
    .badge{
      font-size:12px; padding:6px 10px; border-radius:999px; background:var(--pill); color:var(--muted);
      display:inline-flex; align-items:center; gap:8px; border:1px solid rgba(255,255,255,.08)
    }

    .status-dot{width:8px; height:8px; border-radius:999px; background:#64748b}
    .connected .status-dot{background:var(--accent-2)}
    .streaming .status-dot{background:var(--accent)}
    .stopped .status-dot{background:#64748b}
    .error .status-dot{background:var(--danger)}

    textarea{
      width:100%; min-height:360px; resize:vertical; border-radius:12px; border:1px solid rgba(255,255,255,.08);
      background:#0a1327; color:var(--ink); padding:14px; font:500 15px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      outline:none; box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
    }
    .row{display:flex; gap:10px; flex-wrap:wrap}
    label{font-size:13px; color:var(--muted)}
    select, .pill-input{
      background:#0a1327; color:var(--ink); border:1px solid rgba(255,255,255,.1); padding:10px 12px; border-radius:10px;
      outline:none; font-weight:600
    }
    .kv{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .foot{margin-top:10px; display:flex; justify-content:space-between; align-items:center; color:var(--muted); font-size:12px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px}
    .meter{
      width:100%; height:24px; background:#0a1327; border-radius:6px; overflow:hidden; border:1px solid rgba(255,255,255,.08);
    }
    .meter-fill{
      height:100%; background:linear-gradient(90deg, var(--accent-2), var(--accent)); transition: width 0.1s;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="logo">Rx</div>
      <div>
        <h1>Mediscribe – Live Medical Transcribe</h1>
        <div class="sub">Stream your microphone to the server, which connects to AWS Transcribe Medical, and see live transcripts.</div>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <div class="toolbar">
          <button id="btnStart" class="btn primary">Start Recording</button>
          <button id="btnStop" class="btn stop" disabled>Stop</button>
          <span id="status" class="badge stopped"><span class="status-dot"></span><span id="statusText">disconnected</span></span>
        </div>

        <div class="row" style="gap:16px; margin-bottom:10px">
          <div>
            <label>Language</label><br/>
            <select id="language">
              <option value="en-US" selected>English (US)</option>
            </select>
          </div>
          <div>
            <label>Medical Specialty</label><br/>
            <select id="specialty">
              <option value="PRIMARYCARE" selected>Primary Care</option>
              <option value="CARDIOLOGY">Cardiology</option>
              <option value="NEUROLOGY">Neurology</option>
              <option value="ONCOLOGY">Oncology</option>
              <option value="RADIOLOGY">Radiology</option>
              <option value="UROLOGY">Urology</option>
              <option value="OBGYN">OB/GYN</option>
            </select>
          </div>
          <div>
            <label>Conversation Type</label><br/>
            <select id="convType">
              <option value="CONVERSATION" selected>Clinician–Patient</option>
              <option value="DICTATION">Dictation</option>
            </select>
          </div>
          <div>
            <label>Sample Rate</label><br/>
            <select id="sampleRate">
              <option value="16000" selected>16 kHz</option>
              <option value="8000">8 kHz</option>
            </select>
          </div>
        </div>

        <textarea id="transcript" placeholder="Transcripts will appear here…"></textarea>

        <div class="foot">
          <div class="mono" id="log">Ready.</div>
          <div class="mono">PCM 16-bit • mono • streamed via WebSocket</div>
        </div>
      </section>

      <aside class="card">
        <div class="kv">
          <div style="grid-column: 1 / -1">
            <label>Audio Level</label>
            <div class="meter">
              <div class="meter-fill" id="meterFill" style="width:0%"></div>
            </div>
          </div>
          <div>
            <label>Peak level</label>
            <div class="mono" id="peak">–</div>
          </div>
          <div>
            <label>Connection</label>
            <div class="mono" id="connInfo">–</div>
          </div>
          <div>
            <label>Chunks sent</label>
            <div class="mono" id="sent">0</div>
          </div>
          <div>
            <label>Final lines</label>
            <div class="mono" id="finals">0</div>
          </div>
        </div>
      </aside>
    </div>
  </div>
<script>
const $ = sel => document.querySelector(sel);
const log = msg => { $('#log').textContent = msg; };
const setStatus = (cls, txt) => {
  const s = $('#status');
  s.className = 'badge ' + cls;
  $('#statusText').textContent = txt;
};

let ws, audioCtx, mediaStream, scriptNode, heartbeatTimer, analyser;
let chunksSent = 0, finals = 0, running = false;

function appendTranscript(line, final=false) {
  const ta = $('#transcript');
  if (final) {
    ta.value += (ta.value && !ta.value.endsWith('\n') ? '\n' : '') + line;
    $('#finals').textContent = ++finals;
  } else {
    log('Partial: ' + line);
  }
  ta.scrollTop = ta.scrollHeight;
}

function floatTo16BitPCM(float32Samples) {
  const out = new Int16Array(float32Samples.length);
  for (let i = 0; i < float32Samples.length; i++) {
    let s = Math.max(-1, Math.min(1, float32Samples[i]));
    out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
  }
  return out;
}

// Simple but effective resampling using linear interpolation
function resample(buffer, fromRate, toRate) {
  const ratio = fromRate / toRate;
  const newLength = Math.round(buffer.length / ratio);
  const result = new Float32Array(newLength);
  
  for (let i = 0; i < newLength; i++) {
    const srcIndex = i * ratio;
    const srcIndexFloor = Math.floor(srcIndex);
    const srcIndexCeil = Math.min(srcIndexFloor + 1, buffer.length - 1);
    const t = srcIndex - srcIndexFloor;
    
    // Linear interpolation
    result[i] = buffer[srcIndexFloor] * (1 - t) + buffer[srcIndexCeil] * t;
  }
  
  return result;
}

async function start() {
  if (running) return;
  running = true;
  $('#btnStart').disabled = true;
  $('#btnStop').disabled = false;
  setStatus('connected', 'connecting…');
  log('Requesting microphone…');

  const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/stream';
  ws = new WebSocket(wsUrl);
  ws.binaryType = 'arraybuffer';

  ws.onopen = async () => {
    setStatus('streaming', 'streaming');
    $('#connInfo').textContent = `${location.host} • ws`;
    log('WebSocket connected.');

    try {
      // Request microphone with optimal settings
      mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: false,  // Disable - might be causing issues
          autoGainControl: true,
          channelCount: 1
        },
        video: false
      });

      // Initialize AudioContext (let it use default sample rate)
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      await audioCtx.resume();

      const inputSampleRate = audioCtx.sampleRate;
      const targetSampleRate = 16000;
      
      log(`Audio: ${inputSampleRate}Hz → ${targetSampleRate}Hz`);

      // Create audio source
      const source = audioCtx.createMediaStreamSource(mediaStream);
      
      // Create analyser for visual feedback
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 256;
      source.connect(analyser);
      
      // Create script processor for audio capture
      const bufferSize = 4096;
      scriptNode = audioCtx.createScriptProcessor(bufferSize, 1, 1);
      
      let accumulatedSamples = [];
      const targetChunkSize = 1600; // 100ms at 16kHz
      
      scriptNode.onaudioprocess = (event) => {
        if (!ws || ws.readyState !== 1) return;
        
        const inputBuffer = event.inputBuffer;
        const inputData = inputBuffer.getChannelData(0);
        
        // Update level meter
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteTimeDomainData(dataArray);
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          const normalized = (dataArray[i] - 128) / 128;
          sum += normalized * normalized;
        }
        const rms = Math.sqrt(sum / dataArray.length);
        const db = 20 * Math.log10(rms + 1e-10);
        const level = Math.max(0, Math.min(100, (db + 60) * 1.67)); // -60dB to 0dB → 0-100%
        $('#meterFill').style.width = level + '%';
        $('#peak').textContent = db.toFixed(1) + ' dB';
        
        // Resample to 16kHz
        const resampled = resample(inputData, inputSampleRate, targetSampleRate);
        
        // Accumulate samples
        for (let i = 0; i < resampled.length; i++) {
          accumulatedSamples.push(resampled[i]);
        }
        
        // Send chunks of target size
        while (accumulatedSamples.length >= targetChunkSize) {
          const chunk = new Float32Array(accumulatedSamples.splice(0, targetChunkSize));
          
          // Apply gentle gain if audio is quiet (but don't over-normalize)
          let max = 0;
          for (let i = 0; i < chunk.length; i++) {
            max = Math.max(max, Math.abs(chunk[i]));
          }
          
          // Only boost if audio is between 0.01 and 0.3 (quiet but not silent)
          if (max > 0.01 && max < 0.3) {
            const gain = Math.min(0.5 / max, 2.0);  // Max 2x gain, target 0.5 peak
            for (let i = 0; i < chunk.length; i++) {
              chunk[i] *= gain;
            }
          }
          
          const pcm16 = floatTo16BitPCM(chunk);
          ws.send(pcm16.buffer);
          $('#sent').textContent = ++chunksSent;
        }
      };
      
      source.connect(scriptNode);
      scriptNode.connect(audioCtx.destination);

      // Heartbeat to keep connection alive
      heartbeatTimer = setInterval(() => {
        if (ws && ws.readyState === 1) {
          try { ws.send(new Uint8Array(0)); } catch {}
        }
      }, 8000);

      log('Streaming audio...');

    } catch (err) {
      console.error('Mic init failed:', err);
      log('Microphone init failed: ' + err.message);
      setStatus('error', 'mic error');
    }
  };

  ws.onclose = () => {
    setStatus('stopped', 'disconnected');
    log('WebSocket closed.');
  };

  ws.onerror = e => {
    console.error(e);
    setStatus('error', 'error');
    log('WebSocket error.');
  };

  ws.onmessage = evt => {
    try {
      const text = typeof evt.data === 'string' ? evt.data : new TextDecoder().decode(evt.data);
      if (text.includes('"Transcript"')) {
        const json = JSON.parse(text.slice(text.indexOf('{')));
        const results = json?.Transcript?.Results || [];
        for (const r of results) {
          const t = (r.Alternatives?.[0]?.Transcript || '').trim();
          if (!t) continue;
          appendTranscript(t, !r.IsPartial);
        }
      }
    } catch (err) {
      console.warn('parse error', err);
    }
  };
}

async function stop() {
  if (!running) return;
  running = false;
  $('#btnStop').disabled = true;

  if (heartbeatTimer) clearInterval(heartbeatTimer);
  try { scriptNode && scriptNode.disconnect(); } catch {}
  try { analyser && analyser.disconnect(); } catch {}
  try { audioCtx && await audioCtx.close(); } catch {}
  if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
  if (ws && ws.readyState === 1) try { ws.close(); } catch {}

  $('#btnStart').disabled = false;
  $('#meterFill').style.width = '0%';
  $('#peak').textContent = '–';
  setStatus('stopped', 'stopped');
  log('Stopped.');
}

$('#btnStart').addEventListener('click', start);
$('#btnStop').addEventListener('click', stop);
</script>
</body>
</html>