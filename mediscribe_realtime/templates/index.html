<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mediscribe - Live Medical Transcribe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #1e293b;
      --card: #1e293b;
      --ink: #f8fafc;
      --muted: #94a3b8;
      --accent: #3b82f6;
      --accent-hover: #2563eb;
      --danger: #ef4444;
      --border: #334155;
      --shadow: 0 2px 8px rgba(0,0,0,.35);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body {
      background: var(--bg);
      color: var(--ink);
      font: 500 15px/1.6 "Segoe UI", sans-serif;
      letter-spacing: 0.1px;
    }

    .wrap { max-width: 1100px; margin: auto; padding: 32px; }

    header {
      display: flex; gap: 16px; align-items: center; margin-bottom: 28px;
    }
    .logo {
      width: 48px; height: 48px; display: grid; place-items: center;
      border-radius: 12px;
      background: var(--accent);
      font-weight: 700; color: #fff;
      font-size: 18px;
      box-shadow: var(--shadow);
    }
    h1 { font-size: 22px; margin: 0; color: var(--ink); font-weight: 600; }
    .sub { color: var(--muted); margin-top: 6px; font-size: 15px; }

    .grid {
      display: grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 20px;
    }
    @media (max-width: 960px) { .grid { grid-template-columns: 1fr; } }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 22px 22px 18px;
      box-shadow: var(--shadow);
    }

    .toolbar {
      display: flex; flex-wrap: wrap; gap: 12px; align-items: center;
      margin-bottom: 18px;
    }

    .btn {
      border: none;
      border-radius: 8px;
      padding: 10px 20px;
      cursor: pointer;
      font-weight: 600;
      font-family: "Segoe UI", sans-serif;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.25);
    }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn.small { padding: 8px 14px; font-size: 13px; }

    .primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-hover));
      color: #fff;
    }
    .primary:hover:not(:disabled) {
      filter: brightness(1.1);
      box-shadow: 0 0 0 3px rgba(37,99,235,0.3);
    }

    .secondary {
      background: #334155;
      color: var(--ink);
    }
    .secondary:hover:not(:disabled) {
      background: #3f4f6b;
      box-shadow: 0 0 0 3px rgba(148,163,184,0.25);
    }

    .stop {
      background: linear-gradient(135deg, var(--danger), #b91c1c);
      color: #fff;
    }
    .stop:hover:not(:disabled) {
      filter: brightness(1.15);
      box-shadow: 0 0 0 3px rgba(239,68,68,0.3);
    }

    .badge {
      font-size: 13px;
      padding: 6px 12px;
      border-radius: 999px;
      background: #1e293b;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid var(--border);
      font-weight: 500;
    }
    .status-dot {
      width: 8px; height: 8px; border-radius: 50%; background: #64748b;
    }
    .connected .status-dot { background: #22c55e; }
    .streaming .status-dot { background: var(--accent); }
    .stopped .status-dot { background: #64748b; }
    .error .status-dot { background: var(--danger); }

    textarea {
      width: 100%;
      min-height: 360px;
      resize: vertical;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #111827;
      color: var(--ink);
      padding: 14px;
      font: 500 14px/1.6 "Consolas", "SFMono-Regular", monospace;
      outline: none;
      transition: border .15s, box-shadow .15s;
    }
    textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(37,99,235,0.35);
    }

    label { font-size: 13px; color: var(--muted); }
    select {
      background: #1e293b;
      color: var(--ink);
      border: 1px solid var(--border);
      padding: 10px 12px;
      border-radius: 8px;
      font-weight: 500;
      font-family: "Segoe UI", sans-serif;
      outline: none;
      transition: border .15s, box-shadow .15s, background .15s;
    }
    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(37,99,235,0.3);
      background: #27364d;
    }

    .row { display: flex; gap: 14px; flex-wrap: wrap; }
    .kv { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

    .meter {
      width: 100%;
      height: 18px;
      background: #27364d;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    .meter-fill {
      height: 100%;
      background: linear-gradient(90deg, #22c55e, var(--accent));
      transition: width 0.1s;
    }

    .foot {
      margin-top: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--muted);
      font-size: 12px;
    }
    .mono {
      font-family: "Consolas", monospace;
      font-size: 12px;
    }

    .analysis-section {
      margin-top: 24px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .analysis-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    .analysis-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: var(--ink);
    }
    .analysis-body {
      background: #111827;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      min-height: 150px;
      font-size: 13px;
      color: var(--ink);
    }
    .analysis-block + .analysis-block { margin-top: 12px; }
    .analysis-block h4 {
      margin: 0 0 6px;
      font-size: 13px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }
    .analysis-block ul {
      margin: 0;
      padding-left: 18px;
      list-style: disc;
    }
    .analysis-block li {
      margin-bottom: 6px;
      line-height: 1.5;
    }
    .code-pills {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }
    .code-pill {
      background: rgba(59,130,246,0.15);
      color: #bfdbfe;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-family: "Consolas", monospace;
      border: 1px solid rgba(59,130,246,0.35);
    }
    .muted { color: var(--muted); }
    .analysis-note {
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="logo">Rx</div>
      <div>
        <h1>Mediscribe – Live Medical Transcribe</h1>
        <div class="sub">Stream your microphone to AWS Transcribe Medical for real-time medical transcription.</div>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <div class="toolbar">
          <button id="btnStart" class="btn primary">Resume Recording</button>
          <button id="btnStop" class="btn stop" disabled>Pause</button>
          <button id="btnNew" class="btn secondary">New Transcription</button>
          <span id="status" class="badge stopped"><span class="status-dot"></span><span id="statusText">Disconnected</span></span>
        </div>

        <div class="row" style="gap:16px; margin-bottom:10px">
          <div>
            <label>Language</label><br/>
            <select id="language">
              <option value="en-US" selected>English (US)</option>
            </select>
          </div>
          <div>
            <label>Medical Specialty</label><br/>
            <select id="specialty">
              <option value="PRIMARYCARE" selected>Primary Care</option>
              <option value="CARDIOLOGY">Cardiology</option>
              <option value="NEUROLOGY">Neurology</option>
              <option value="ONCOLOGY">Oncology</option>
              <option value="RADIOLOGY">Radiology</option>
              <option value="UROLOGY">Urology</option>
            </select>
          </div>
          <div>
            <label>Conversation Type</label><br/>
            <select id="convType">
              <option value="CONVERSATION" selected>Clinician–Patient</option>
              <option value="DICTATION">Dictation</option>
            </select>
          </div>
          <div>
            <label>Sample Rate</label><br/>
            <select id="sampleRate">
              <option value="16000" selected>16 kHz</option>
              <option value="8000">8 kHz</option>
            </select>
          </div>
        </div>

        <textarea id="transcript" placeholder="Transcripts will appear here..."></textarea>

        <div class="foot">
          <div class="mono" id="log">Ready.</div>
          <div class="mono">PCM 16-bit • 16kHz mono • streamed via WebSocket</div>
        </div>
      </section>

      <aside class="card">
        <div class="kv">
          <div style="grid-column: 1 / -1">
            <label>Audio Level (shows green when speaking)</label>
            <div class="meter">
              <div class="meter-fill" id="meterFill" style="width:0%"></div>
            </div>
          </div>
          <div>
            <label>Peak Level</label>
            <div class="mono" id="peak">–</div>
          </div>
          <div>
            <label>RMS Level</label>
            <div class="mono" id="rms">–</div>
          </div>
          <div>
            <label>Chunks Sent</label>
            <div class="mono" id="sent">0</div>
          </div>
          <div>
            <label>Final Lines</label>
            <div class="mono" id="finals">0</div>
          </div>
        </div>
        <div class="analysis-section">
          <div class="analysis-header">
            <h3>Clinical Insights</h3>
            <button id="btnAnalyze" class="btn secondary small">Analyze Notes</button>
          </div>
          <div id="analysisResults" class="analysis-body">
            <p class="muted">Run analysis to extract clinical entities and billing codes.</p>
          </div>
        </div>
      </aside>
    </div>
  </div>

<script>
const $ = sel => document.querySelector(sel);
const log = msg => { $('#log').textContent = msg; };
const setStatus = (cls, txt) => {
  const s = $('#status');
  s.className = 'badge ' + cls;
  $('#statusText').textContent = txt;
};

const analysisDefaultMsg = 'Run analysis to extract clinical entities and billing codes.';

function resetAnalysis(message = analysisDefaultMsg) {
  const container = $('#analysisResults');
  if (!container) return;
  container.innerHTML = '';
  const p = document.createElement('p');
  p.className = 'muted';
  p.textContent = message;
  container.appendChild(p);
}

function createCodePills(label, codes = []) {
  if (!codes || !codes.length) return null;
  const wrap = document.createElement('div');
  wrap.className = 'code-pills';
  codes.slice(0, 3).forEach(concept => {
    if (!concept?.code) return;
    const pill = document.createElement('span');
    pill.className = 'code-pill';
    const parts = [label, concept.code];
    if (concept.description) parts.push(concept.description);
    pill.textContent = parts.join(' • ');
    if (concept.description) pill.title = concept.description;
    wrap.appendChild(pill);
  });
  return wrap.childNodes.length ? wrap : null;
}

function renderAnalysis(data) {
  const container = $('#analysisResults');
  if (!container) return;

  const entities = data?.entities || {};
  const sections = [
    ['Conditions', entities.conditions],
    ['Tests', entities.tests],
    ['Treatments', entities.treatments],
    ['Procedures', entities.procedures],
  ];

  container.innerHTML = '';
  let hasResults = false;

  sections.forEach(([label, items]) => {
    const block = document.createElement('div');
    block.className = 'analysis-block';
    const heading = document.createElement('h4');
    heading.textContent = label;
    block.appendChild(heading);

    if (!items || !items.length) {
      const empty = document.createElement('p');
      empty.className = 'muted';
      empty.textContent = `No ${label.toLowerCase()} identified.`;
      block.appendChild(empty);
    } else {
      hasResults = true;
      const list = document.createElement('ul');
      items.forEach(item => {
        const li = document.createElement('li');
        const strong = document.createElement('strong');
        strong.textContent = item.text;
        li.appendChild(strong);

        if (typeof item.confidence === 'number') {
          const conf = document.createElement('span');
          conf.className = 'muted';
          conf.textContent = ` (${(item.confidence * 100).toFixed(1)}% confidence)`;
          li.appendChild(conf);
        }

        if (Array.isArray(item.traits) && item.traits.length) {
          const traitsSpan = document.createElement('span');
          traitsSpan.className = 'muted';
          const traits = item.traits
            .map(t => (t.name || '').toLowerCase().replace(/_/g, ' '))
            .filter(Boolean);
          if (traits.length) {
            traitsSpan.textContent = ` • traits: ${traits.join(', ')}`;
            li.appendChild(traitsSpan);
          }
        }

        const icdCodes = createCodePills('ICD-10', item.icd10);
        if (icdCodes) li.appendChild(icdCodes);

        const snomedCodes = createCodePills('SNOMED CT', item.snomed);
        if (snomedCodes) li.appendChild(snomedCodes);

        list.appendChild(li);
      });
      block.appendChild(list);
    }

    container.appendChild(block);
  });

  if (!hasResults) {
    resetAnalysis('No clinical entities were detected in the current note.');
    return;
  }

  if (data?.truncated) {
    const note = document.createElement('div');
    note.className = 'analysis-note';
    note.textContent = 'Note: the transcription was truncated to the first 20,000 characters for Comprehend Medical.';
    container.appendChild(note);
  }
}

let ws, audioCtx, mediaStream, processor, heartbeatTimer;
let chunksSent = 0, finals = 0, running = false;

function appendTranscript(line, final=false) {
  const ta = $('#transcript');
  if (final) {
    ta.value += (ta.value && !ta.value.endsWith('\n') ? '\n' : '') + line;
    $('#finals').textContent = ++finals;
  } else {
    log('Partial: ' + line);
  }
  ta.scrollTop = ta.scrollHeight;
}

// Proper linear interpolation resampler
function resample(input, inputRate, outputRate) {
  const ratio = inputRate / outputRate;
  const outputLength = Math.round(input.length / ratio);
  const output = new Float32Array(outputLength);
  
  for (let i = 0; i < outputLength; i++) {
    const srcPos = i * ratio;
    const srcIdx = Math.floor(srcPos);
    const nextIdx = Math.min(srcIdx + 1, input.length - 1);
    const frac = srcPos - srcIdx;
    
    output[i] = input[srcIdx] * (1 - frac) + input[nextIdx] * frac;
  }
  
  return output;
}

// Convert float32 to int16 PCM
function floatToPCM16(input) {
  const output = new Int16Array(input.length);
  for (let i = 0; i < input.length; i++) {
    const s = Math.max(-1, Math.min(1, input[i]));
    output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
  }
  return output;
}

async function newTranscription() {
  const btn = $('#btnNew');
  if (btn) btn.disabled = true;
  try {
    await stop();
    $('#transcript').value = '';
    chunksSent = 0;
    finals = 0;
    $('#sent').textContent = '0';
    $('#finals').textContent = '0';
    resetAnalysis();
    log('Starting a fresh transcription…');
    await start();
  } finally {
    if (btn) btn.disabled = false;
  }
}

async function analyzeTranscript() {
  const btn = $('#btnAnalyze');
  if (btn) btn.disabled = true;
  try {
    const text = ($('#transcript').value || '').trim();
    if (!text) {
      resetAnalysis('Nothing to analyze yet — record or type a note first.');
      log('No transcript available for analysis.');
      return;
    }

    log('Sending transcript to AWS Comprehend Medical…');
    const response = await fetch('/analyze', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text }),
    });

    if (!response.ok) {
      let detail = 'Unable to analyze notes.';
      try {
        const error = await response.json();
        if (error?.detail) detail = error.detail;
      } catch {}
      throw new Error(detail);
    }

    const data = await response.json();
    renderAnalysis(data);
    log(data?.truncated ? 'Analysis complete (input truncated to 20k characters).' : 'Analysis complete.');
  } catch (err) {
    console.error('Analysis error:', err);
    resetAnalysis(`Analysis failed: ${err.message}`);
    log('Analysis failed: ' + err.message);
  } finally {
    if (btn) btn.disabled = false;
  }
}

async function start() {
  if (running) return;
  running = true;
  $('#btnStart').disabled = true;
  $('#btnStop').disabled = false;
  setStatus('connected', 'connecting…');
  log('Requesting microphone…');

  
  //const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/stream';
  const params = new URLSearchParams({
    language: $('#language').value,
    specialty: $('#specialty').value,
    conversationType: $('#convType').value,
    sampleRate: $('#sampleRate').value,
  });
  const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') +
    location.host + '/stream?' + params.toString();
  ws = new WebSocket(wsUrl);
  ws.binaryType = 'arraybuffer';

  ws.onopen = async () => {
    setStatus('streaming', 'streaming');
    log('WebSocket connected.');

    try {
      // Request mic with minimal processing
      mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,  // Disable AGC to prevent clipping
          channelCount: 1
        }
      });

      log('Microphone access granted');

      // Create audio context with default sample rate
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      await audioCtx.resume();
      
      const inputSampleRate = audioCtx.sampleRate;
      const targetSampleRate = parseInt($('#sampleRate').value, 10) || 16000;
      
      log(`Audio: ${inputSampleRate}Hz → ${targetSampleRate}Hz`);

      const source = audioCtx.createMediaStreamSource(mediaStream);
      
      // Use ScriptProcessor for reliable audio capture
      const bufferSize = 4096;
      processor = audioCtx.createScriptProcessor(bufferSize, 1, 1);
      
      let accumulatedSamples = [];
      const targetChunkSize = 1600; // 100ms at 16kHz
      
      processor.onaudioprocess = (event) => {
        if (!ws || ws.readyState !== 1) return;
        
        // CRITICAL: Copy the data to prevent reuse issues
        const inputBuffer = event.inputBuffer.getChannelData(0);
        const inputData = new Float32Array(inputBuffer);
        
        // Calculate actual audio levels for display
        let sumSquares = 0;
        let peak = 0;
        for (let i = 0; i < inputData.length; i++) {
          const val = inputData[i];
          sumSquares += val * val;
          peak = Math.max(peak, Math.abs(val));
        }
        const rms = Math.sqrt(sumSquares / inputData.length);
        
        // Log raw input levels for debugging
        if (chunksSent === 0) {
          console.log('First raw input - Peak:', peak, 'RMS:', rms);
        }
        
        // Update display
        $('#rms').textContent = rms.toFixed(4);
        $('#peak').textContent = peak.toFixed(4);
        const meterLevel =Math.min(100, Math.pow(peak, 0.5) * 100); // Scale for visibility
        $('#meterFill').style.width = meterLevel + '%';
        
        // Resample to 16kHz
        const resampled = resample(inputData, inputSampleRate, targetSampleRate);
        
        // Accumulate samples
        for (let i = 0; i < resampled.length; i++) {
          accumulatedSamples.push(resampled[i]);
        }
        
        // Send when we have enough samples
        while (accumulatedSamples.length >= targetChunkSize) {
          const chunk = new Float32Array(accumulatedSamples.splice(0, targetChunkSize));
          const pcm16 = floatToPCM16(chunk);
          
          // Send as Int16Array directly, not as Float32
          ws.send(chunk.buffer);
          $('#sent').textContent = ++chunksSent;
        }
      };
      
      source.connect(processor);
      processor.connect(audioCtx.destination);

      // Heartbeat
      heartbeatTimer = setInterval(() => {
        if (ws && ws.readyState === 1) {
          try { ws.send(new Uint8Array(0)); } catch {}
        }
      }, 8000);

      log('Streaming… Speak clearly into your microphone.');

    } catch (err) {
      console.error('Mic error:', err);
      log('Microphone error: ' + err.message);
      setStatus('error', 'mic error');
    }
  };

  ws.onclose = () => {
    setStatus('stopped', 'disconnected');
    log('WebSocket closed.');
  };

  ws.onerror = e => {
    console.error(e);
    setStatus('error', 'error');
    log('WebSocket error.');
  };

  ws.onmessage = evt => {
    try {
      const text = typeof evt.data === 'string' ? evt.data : new TextDecoder().decode(evt.data);
      if (text.includes('"Transcript"')) {
        const json = JSON.parse(text.slice(text.indexOf('{')));
        const results = json?.Transcript?.Results || [];
        for (const r of results) {
          const t = (r.Alternatives?.[0]?.Transcript || '').trim();
          if (!t) continue;
          appendTranscript(t, !r.IsPartial);
        }
      }
    } catch (err) {
      console.warn('parse error', err);
    }
  };
}

async function stop() {
  if (!running) return;
  running = false;
  $('#btnStop').disabled = true;

  if (heartbeatTimer) clearInterval(heartbeatTimer);
  heartbeatTimer = null;
  try { processor && processor.disconnect(); } catch {}
  processor = null;
  try { audioCtx && await audioCtx.close(); } catch {}
  audioCtx = null;
  if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
  mediaStream = null;
  if (ws && ws.readyState === 1) try { ws.close(); } catch {}
  ws = null;

  $('#btnStart').disabled = false;
  $('#meterFill').style.width = '0%';
  $('#peak').textContent = '–';
  $('#rms').textContent = '–';
  setStatus('stopped', 'paused');
  log('Paused.');
}

$('#btnStart').addEventListener('click', start);
$('#btnStop').addEventListener('click', stop);
$('#btnNew').addEventListener('click', () => {
  newTranscription().catch(err => {
    console.error('New transcription error:', err);
    log('Unable to start a new transcription: ' + err.message);
  });
});
$('#btnAnalyze').addEventListener('click', analyzeTranscript);

resetAnalysis();
</script>
</body>
</html>
